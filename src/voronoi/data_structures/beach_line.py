"""Beach line data structure for Fortune's sweep line algorithm."""

from typing import Optional, List, Tuple
import math
from .point import Point
from .edge import Edge, HalfEdge


class Arc:
    """
    An arc on the beach line representing a parabola generated by a site.
    Each arc corresponds to a portion of a parabola that is visible on the beach line.
    """

    def __init__(self, site: Point):
        self.site = site

        # Pointers to adjacent arcs in the beach line
        self.left_arc: Optional['Arc'] = None
        self.right_arc: Optional['Arc'] = None

        # Half-edges that bound this arc
        self.left_edge: Optional[HalfEdge] = None
        self.right_edge: Optional[HalfEdge] = None

        # Circle event associated with this arc (if any)
        self.circle_event: Optional['CircleEvent'] = None

        # Unique identifier for debugging
        self.id: int = Arc._next_id
        Arc._next_id += 1

    _next_id: int = 0

    def __str__(self) -> str:
        return f"Arc({self.site})"

    def __repr__(self) -> str:
        return f"Arc(id={self.id}, site={self.site})"

    def get_y_at_x(self, x: float, sweep_y: float) -> float:
        """
        Calculate the y-coordinate of this arc's parabola at given x.

        Args:
            x: The x-coordinate
            sweep_y: Current position of the sweep line

        Returns:
            The y-coordinate of the parabola at x
        """
        if abs(self.site.y - sweep_y) < 1e-10:
            # Degenerate case: site is on sweep line (infinite slope)
            return float('inf') if self.site.y > sweep_y else float('-inf')

        # Standard parabola equation: (x - h)² = 4p(y - k)
        # where focus is at (h, k) and directrix is y = k - 2p
        # Here, focus = site, directrix = sweep_y
        dx = x - self.site.x
        dy = self.site.y - sweep_y

        if abs(dy) < 1e-10:
            return self.site.y

        return (dx * dx) / (2 * dy) + (self.site.y + sweep_y) / 2

    def get_intersection_x(self, other: 'Arc', sweep_y: float) -> Optional[float]:
        """
        Find the x-coordinate where this arc intersects with another arc.

        Args:
            other: The other arc
            sweep_y: Current position of the sweep line

        Returns:
            The x-coordinate of intersection, or None if no intersection
        """
        if self.site == other.site:
            return None

        # Special cases where one site is on the sweep line
        if abs(self.site.y - sweep_y) < 1e-10:
            return self.site.x
        if abs(other.site.y - sweep_y) < 1e-10:
            return other.site.x

        # General case: solve quadratic equation for intersection
        # Parabola 1: y = (x - x1)² / (2 * (y1 - sweep_y)) + (y1 + sweep_y) / 2
        # Parabola 2: y = (x - x2)² / (2 * (y2 - sweep_y)) + (y2 + sweep_y) / 2

        x1, y1 = self.site.x, self.site.y
        x2, y2 = other.site.x, other.site.y

        dy1 = y1 - sweep_y
        dy2 = y2 - sweep_y

        if abs(dy1) < 1e-10 or abs(dy2) < 1e-10:
            return None

        # Coefficients for quadratic equation ax² + bx + c = 0
        a = 1 / (2 * dy1) - 1 / (2 * dy2)

        if abs(a) < 1e-10:
            # Linear equation (parallel parabolas)
            if abs(x1 - x2) < 1e-10:
                return None
            return (x1 + x2) / 2

        b = -x1 / dy1 + x2 / dy2
        c = (x1 * x1) / (2 * dy1) - (x2 * x2) / (2 * dy2) + (y2 - y1) / 2

        discriminant = b * b - 4 * a * c

        if discriminant < 0:
            return None

        sqrt_discriminant = math.sqrt(discriminant)

        # Choose the appropriate root based on the relative positions of the sites
        if y1 < y2:
            return (-b + sqrt_discriminant) / (2 * a)
        else:
            return (-b - sqrt_discriminant) / (2 * a)


class BeachLine:
    """
    The beach line data structure for Fortune's algorithm.
    Maintains the sequence of arcs that form the current beach line.
    """

    def __init__(self):
        self.root: Optional[Arc] = None
        self.leftmost: Optional[Arc] = None
        self.rightmost: Optional[Arc] = None

    def is_empty(self) -> bool:
        """Check if the beach line is empty."""
        return self.root is None

    def insert_first_arc(self, site: Point) -> Arc:
        """Insert the first arc when the beach line is empty."""
        arc = Arc(site)
        self.root = arc
        self.leftmost = arc
        self.rightmost = arc
        return arc

    def find_arc_above(self, x: float, sweep_y: float) -> Optional[Arc]:
        """
        Find the arc that lies directly above the given x-coordinate.

        Args:
            x: The x-coordinate to search
            sweep_y: Current position of the sweep line

        Returns:
            The arc above the point, or None if beach line is empty
        """
        if self.is_empty():
            return None

        # Linear search through arcs (could be optimized with balanced tree)
        current = self.leftmost
        while current:
            # Check if this arc covers the x-coordinate
            left_bound = float('-inf')
            right_bound = float('inf')

            # Find left boundary
            if current.left_arc:
                left_intersection = current.left_arc.get_intersection_x(current, sweep_y)
                if left_intersection is not None:
                    left_bound = left_intersection

            # Find right boundary
            if current.right_arc:
                right_intersection = current.get_intersection_x(current.right_arc, sweep_y)
                if right_intersection is not None:
                    right_bound = right_intersection

            # Check if x falls within this arc's range
            if left_bound <= x <= right_bound:
                return current

            current = current.right_arc

        # If we get here, return the rightmost arc as fallback
        return self.rightmost

    def split_arc(self, arc: Arc, site: Point) -> Tuple[Arc, Arc, Arc]:
        """
        Split an arc by inserting a new site, creating three arcs.

        Args:
            arc: The arc to split
            site: The new site causing the split

        Returns:
            Tuple of (left_arc, middle_arc, right_arc)
        """
        # Create new arcs
        left_arc = Arc(arc.site)
        middle_arc = Arc(site)
        right_arc = Arc(arc.site)

        # Set up the linked structure
        left_arc.right_arc = middle_arc
        middle_arc.left_arc = left_arc
        middle_arc.right_arc = right_arc
        right_arc.left_arc = middle_arc

        # Update connections with neighboring arcs
        if arc.left_arc:
            arc.left_arc.right_arc = left_arc
            left_arc.left_arc = arc.left_arc

        if arc.right_arc:
            arc.right_arc.left_arc = right_arc
            right_arc.right_arc = arc.right_arc

        # Update beach line boundaries
        if arc == self.leftmost:
            self.leftmost = left_arc
        if arc == self.rightmost:
            self.rightmost = right_arc

        # Update root if necessary
        if arc == self.root:
            self.root = middle_arc

        return left_arc, middle_arc, right_arc

    def remove_arc(self, arc: Arc) -> None:
        """
        Remove an arc from the beach line.

        Args:
            arc: The arc to remove
        """
        # Update neighboring arcs
        if arc.left_arc:
            arc.left_arc.right_arc = arc.right_arc
        if arc.right_arc:
            arc.right_arc.left_arc = arc.left_arc

        # Update beach line boundaries
        if arc == self.leftmost:
            self.leftmost = arc.right_arc
        if arc == self.rightmost:
            self.rightmost = arc.left_arc

        # Update root if necessary
        if arc == self.root:
            if arc.left_arc:
                self.root = arc.left_arc
            elif arc.right_arc:
                self.root = arc.right_arc
            else:
                self.root = None

    def get_triple(self, arc: Arc) -> Optional[Tuple[Arc, Arc, Arc]]:
        """
        Get a triple of consecutive arcs centered on the given arc.

        Args:
            arc: The center arc

        Returns:
            Tuple of (left, center, right) or None if not possible
        """
        if not arc.left_arc or not arc.right_arc:
            return None

        return arc.left_arc, arc, arc.right_arc

    def get_all_arcs(self) -> List[Arc]:
        """Get all arcs in left-to-right order."""
        arcs = []
        current = self.leftmost
        while current:
            arcs.append(current)
            current = current.right_arc
        return arcs

    def validate(self) -> bool:
        """
        Validate the integrity of the beach line structure.
        Returns True if valid, False otherwise.
        """
        if self.is_empty():
            return self.leftmost is None and self.rightmost is None

        # Check that leftmost has no left neighbor
        if self.leftmost and self.leftmost.left_arc is not None:
            return False

        # Check that rightmost has no right neighbor
        if self.rightmost and self.rightmost.right_arc is not None:
            return False

        # Check bidirectional consistency
        current = self.leftmost
        while current and current.right_arc:
            if current.right_arc.left_arc != current:
                return False
            current = current.right_arc

        return True